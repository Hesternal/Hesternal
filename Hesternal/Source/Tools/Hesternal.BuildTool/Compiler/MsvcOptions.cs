using static Hesternal.BuildTool.Msvc;

namespace Hesternal.BuildTool;


[SupportedLinkers(typeof(MsvcLibrarianOptions), typeof(MsvcLinkerOptions))]
public sealed class MsvcOptions : ICompilerOptions
{
    #region General

    /// <summary>
    /// Makes the build scan all c++ sources, not just module interface and header unit sources, for module and header units dependencies and build the full dependencies graph.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /scanDependencies
    /// </remarks>
    [CompilerFlag.Bool("/scanDependencies")]
    public bool ScanSourceForModuleDependencies = false;

    /// <summary>
    /// Enables the compiler to translate #include directives into import directives for the available header units.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /translateInclude
    /// </remarks>
    [CompilerFlag.Bool("/translateInclude")]
    public bool TranslateIncludesToImports = false;

    // NOTE(v.matushkin): While doc says that there is /JMC- flag, in Microsoft.Build.CPPTasks.Common it only takes /JMC ?
    /// <summary>
    /// Enables the compiler to translate #include directives into import directives for the available header units.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /JMC, <see langword="false"/> /JMC-
    /// </remarks>
    [CompilerFlag.Bool("/JMC", "/JMC-")]
    public bool SupportJustMyCode = true;

    /// <summary>
    /// Specifies the type of debugging information generated by the compiler. This requires compatible linker settings.<br/>
    /// The /ZI option forces both the /Gy (Enable Function-Level Linking) and /FC (Full Path of Source Code File in Diagnostics) options to be used in your compilation.
    /// </summary>
    public DebugInformationFormat DebugInformationFormat = DebugInformationFormat.ProgramDatabase;

    /// <summary>
    /// Suppresses the display of the sign-on banner when the compiler starts up and display of informational messages during compiling.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /nologo
    /// </remarks>
    [CompilerFlag.Bool("/nologo")]
    public bool SuppressStartupBanner = true;

    /// <summary>
    /// Select how strict you want the compiler to be about code errors.
    /// </summary>
    public WarningLevel WarningLevel = WarningLevel.Level1;

    /// <summary>
    /// Treats all compiler warnings as errors.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /WX, <see langword="false"/> /WX-
    /// </remarks>
    [CompilerFlag.Bool("/WX", "/WX-")]
    public bool TreatWarningAsError = false;

    /// <summary>
    /// Enables rich diagnostics, with column information and source context in diagnostic messages.
    /// </summary>
    public DiagnosticsFormat DiagnosticsFormat = DiagnosticsFormat.Column;

    /// <summary>
    /// Additional Security Development Lifecycle (SDL) recommended checks;
    /// includes enabling additional secure code generation features and enables extra security-relevant warnings as errors.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /sdl, <see langword="false"/> /sdl-
    /// </remarks>
    [CompilerFlag.Bool("/sdl", "/sdl-")]
    public bool SDLCheck = false;

    /// <remarks>
    /// <see langword="true"/> /MP
    /// </remarks>
    [CompilerFlag.Bool("/MP")]
    public bool MultiProcessorCompilation = true;

    /// <summary>
    /// Compiles and links program with AddressSanitizer. Currently available for x86 and x64 builds.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /fsanitize=address
    /// </remarks>
    [CompilerFlag.Bool("/fsanitize=address")]
    public bool EnableASAN = false;

    /// <summary>
    /// Compiles programs with the Fuzzer. Enable AddressSanitizer for best results. Currently available for x86 and x64 builds.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /fsanitize=fuzzer
    /// </remarks>
    [CompilerFlag.Bool("/fsanitize=fuzzer")]
    public bool EnableFuzzer = false;

    #endregion General


    #region Optimization

    /// <summary>
    /// Select option for code optimization; choose Custom to use specific optimization options.
    /// </summary>
    public Optimization Optimization = Optimization.Disabled;

    /// <summary>
    /// Select the level of inline function expansion for the build.
    /// </summary>
    public InlineFunctionExpansion InlineFunctionExpansion = InlineFunctionExpansion.Default;

    /// <summary>
    /// Enables intrinsic functions. Using intrinsic functions generates faster, but possibly larger, code.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Oi
    /// </remarks>
    [CompilerFlag.Bool("/Oi")]
    public bool IntrinsicFunctions = false;

    /// <summary>
    /// Whether to favor code size or code speed; 'Global Optimization' must be turned on.
    /// </summary>
    public FavorSizeOrSpeed FavorSizeOrSpeed = FavorSizeOrSpeed.Neither;

    /// <summary>
    /// Suppresses creation of frame pointers on the call stack.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Oy, <see langword="false"/> /Oy-
    /// </remarks>
    [CompilerFlag.Bool("/Oy", "Oy-")]
    public bool OmitFramePointers = false;

    /// <summary>
    /// Enables memory space optimization when using fibers and thread local storage access.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /GT
    /// </remarks>
    [CompilerFlag.Bool("/GT")]
    public bool EnableFiberSafeOptimizations = false;

    /// <summary>
    /// Enables cross-module optimizations by delaying code generation to link time; requires that linker option 'Link Time Code Generation' be turned on.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /GL
    /// </remarks>
    [CompilerFlag.Bool("/GL")]
    public bool WholeProgramOptimization = false;

    #endregion Optimization


    #region Preprocessor

    // NOTE(v.matushkin): Does it actually undefines everything or only MSVC predefined macros?
    //  https://docs.microsoft.com/en-us/cpp/build/reference/u-u-undefine-symbols?view=msvc-170
    /// <summary>
    /// Undefine all previously defined preprocessor values.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /u
    /// </remarks>
    [CompilerFlag.Bool("/u")]
    public bool UndefineAllPreprocessorDefinitions = false;

    /// <summary>
    /// Prevents the compiler from searching for include files in directories specified in the INCLUDE environment variables.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /X
    /// </remarks>
    [CompilerFlag.Bool("/X")]
    public bool IgnoreStandardIncludePath = false;

    /// <summary>
    /// Preprocesses C and C++ source files and writes the preprocessed output to a file. This option suppresses compilation, thus it does not produce an .obj file.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /P
    /// </remarks>
    [CompilerFlag.Bool("/P")]
    public bool PreprocessToFile = false;

    // public string PreprocessOutputPath

    /// <summary>
    /// Preprocess without #line directives.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /EP
    /// </remarks>
    [CompilerFlag.Bool("/EP")]
    public bool PreprocessSuppressLineNumbers = false;

    /// <summary>
    /// Suppresses comment strip from source code; requires that one of the 'Preprocessing' options (/E, /P, or /EP) be set.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /C
    /// </remarks>
    [CompilerFlag.Bool("/C")]
    public bool PreprocessKeepComments = false;

    /// <summary>
    /// Use a standard conforming preprocessor. Currently implied by /std:c11 and /std:c17. To use legacy preprocessor set this property to 'No'.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zc:preprocessor, <see langword="false"/> /Zc:preprocessor-
    /// </remarks>
    [CompilerFlag.Bool("/Zc:preprocessor", "/Zc:preprocessor-")]
    public bool UseStandardPreprocessor = false;

    #endregion Preprocessor


    #region Code generation

    /// <summary>
    /// Enables the compiler to create a single read-only copy of identical strings in the program image and in memory during execution,
    /// resulting in smaller programs, an optimization called string pooling. /O1, /O2, and /ZI automatically set this option.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /GF, <see langword="false"/> /GF-
    /// </remarks>
    [CompilerFlag.Bool("/GF", "/GF-")]
    public bool? StringPooling = null;

    /// <summary>
    /// Enables minimal rebuild, which determines whether C++ source files that include changed C++ class definitions (stored in header (.h) files) need to be recompiled.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Gm, <see langword="false"/> /Gm-
    /// </remarks>
    [CompilerFlag.Bool("/Gm", "/Gm-")]
    public bool MinimalRebuild = false;

    /// <summary>
    /// Specifies the model of exception handling to be used by the compiler.
    /// </summary>
    public ExceptionHandling ExceptionHandling = ExceptionHandling.Sync;

    /// <summary>
    /// Enable checking for conversion to smaller types, incompatible with any optimization type other than debug.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /RTCc
    /// </remarks>
    [CompilerFlag.Bool("/RTCc")]
    public bool SmallerTypeCheck = false;

    /// <summary>
    /// Perform basic runtime error checks, incompatible with any optimization type other than debug.
    /// </summary>
    public BasicRuntimeChecks BasicRuntimeChecks = BasicRuntimeChecks.Default;

    /// <summary>
    /// Specify runtime library for linking.
    /// </summary>
    public RuntimeLibrary RuntimeLibrary = RuntimeLibrary.MultiThreadedDLL;

    /// <summary>
    /// Controls how the members of a structure are packed into memory and specifies the same packing for all structures in a module.
    /// </summary>
    public StructMemberAlignment StructMemberAlignment = StructMemberAlignment.Default;

    /// <summary>
    /// Detects some buffer overruns that overwrite a function's return address, exception handler address, or certain types of parameters.<br/>
    /// Causing a buffer overrun is a technique used by hackers to exploit code that does not enforce buffer size restrictions.
    /// </summary>
    public BufferSecurityCheck BufferSecurityCheck = BufferSecurityCheck.True;

    /// <summary>
    /// Enable compiler generation of Control Flow Guard security checks. Guard security check helps detect attempts to dispatch to illegal block of code.
    /// </summary>
    public ControlFlowGuard? ControlFlowGuard = null;

    /// <summary>
    /// Allows the compiler to package individual functions in the form of packaged functions (COMDATs). Required for edit and continue to work.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Gy, <see langword="false"/> /Gy-
    /// </remarks>
    [CompilerFlag.Bool("/Gy", "/Gy-")]
    public bool? FunctionLevelLinking = null;

    /// <summary>
    /// Allows the compiler to generate parallel code for loops identified using #pragma loop(hint_parallel[(n)]) when optimization is enabled.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Qpar, <see langword="false"/> /Qpar-
    /// </remarks>
    [CompilerFlag.Bool("/Qpar", "/Qpar-")]
    public bool? EnableParallelCodeGeneration = null;

    /// <summary>
    /// Enable use of instructions found on processors that support enhanced instruction sets, e.g., the SSE, SSE2, AVX, AVX2 and AVX-512 enhancements to IA-32;<br/>
    /// AVX, AVX2 and AVX-512 to x64. Currently /arch:SSE and /arch:SSE2 are only available when building for the x86 architecture.<br/>
    /// If no option is specified, the compiler will use instructions found on processors that support SSE2. Use of enhanced instructions can be disabled with /arch:IA32.
    /// </summary>
    public EnableEnhancedInstructionSet EnableEnhancedInstructionSet = EnableEnhancedInstructionSet.NotSet;

    /// <summary>
    /// Sets the floating point model.
    /// </summary>
    public FloatingPointModel FloatingPointModel = FloatingPointModel.Precise;

    /// <summary>
    /// Reliable floating-point exception model. Exceptions will be raised immediately after they are triggered.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /fp:except, <see langword="false"/> /fp:except-
    /// </remarks>
    [CompilerFlag.Bool("/fp:except", "/fp:except-")]
    public bool? FloatingPointExceptions = null;

    /// <summary>
    /// When hotpatching is on, the compiler ensures that first instruction of each function is two bytes, which is required for hot patching.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /hotpatch
    /// </remarks>
    [CompilerFlag.Bool("/hotpatch")]
    public bool? CreateHotpatchableImage = null;

    /// <summary>
    /// Spectre mitigations for CVE 2017-5753. Specifies compiler generation of instructions to mitigate certain Spectre variant 1 security vulnerabilities.
    /// </summary>
    public SpectreMitigation SpectreMitigation = SpectreMitigation.False;

    /// <summary>
    /// Specifies that the compiler generates instructions to mitigate the performance impact caused by the Intel Jump Conditional Code (JCC) erratum microcode update in certain Intel processors.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /QIntel-jcc-erratum
    /// </remarks>
    [CompilerFlag.Bool("/QIntel-jcc-erratum")]
    public bool IntelJCCErratum = false;

    /// <summary>
    /// Generates a sorted list of all the valid exception handling continuation targets for a binary, used during runtime for RIP validation. Currently available for x64 builds.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /guard:ehcont, <see langword="false"/> /guard:ehcont-
    /// </remarks>
    [CompilerFlag.Bool("/guard:ehcont", "/guard:ehcont-")]
    public bool? GuardEHContMetadata = null;

    /// <summary>
    /// Enables signed returns which help detect and prevent attempts to dispatch to illegal blocks from function returns. Currently available for ARM64 builds.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /guard:signret, <see langword="false"/> /guard:signret-
    /// </remarks>
    [CompilerFlag.Bool("/guard:signret", "/guard:signret-")]
    public bool? GuardSignedReturns = null;

    #endregion Code generation


    #region Language

    /// <summary>
    /// Suppresses or enables language extensions.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Za
    /// </remarks>
    [CompilerFlag.Bool("/Za")]
    public bool DisableLanguageExtensions = false;

    /// <summary>
    /// When specified, the type wchar_t becomes a native type that maps to __wchar_t in the same way that short maps to __int16. /Zc:wchar_t is on by default.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zc:wchar_t, <see langword="false"/> /Zc:wchar_t-
    /// </remarks>
    [CompilerFlag.Bool("/Zc:wchar_t", "/Zc:wchar_t-")]
    public bool TreatWChar_tAsBuiltInType = true;

    /// <summary>
    /// Used to implement standard C++ behavior for the for statement loops with Microsoft extensions (/Za, /Ze (Disable Language Extensions)). /Zc:forScope is on by default.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zc:forScope, <see langword="false"/> /Zc:forScope-
    /// </remarks>
    [CompilerFlag.Bool("/Zc:forScope", "/Zc:forScope-")]
    public bool ForceConformanceInForLoopScope = true;

    /// <summary>
    /// When specified, compiler no longer generates symbol information for unreferenced code and data.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zc:inline
    /// </remarks>
    [CompilerFlag.Bool("/Zc:inline")]
    public bool RemoveUnreferencedCodeData = true;

    /// <summary>
    /// Used to identify an rvalue reference type as the result of a cast operation in accordance with the C++11 standard.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zc:rvalueCast, <see langword="false"/> /Zc:rvalueCast-
    /// </remarks>
    [CompilerFlag.Bool("/Zc:rvalueCast", "/Zc:rvalueCast-")]
    public bool? EnforceTypeConversionRules = null;

    /// <summary>
    /// Adds code for checking C++ object types at run time (runtime type information).
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /GR, <see langword="false"/> /GR-
    /// </remarks>
    [CompilerFlag.Bool("/GR", "/GR-")]
    public bool? RuntimeTypeInfo = null;

    /// <summary>
    /// Enable OpenMP 2.0 language extensions.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /openmp, <see langword="false"/> /openmp-
    /// </remarks>
    [CompilerFlag.Bool("/openmp", "/openmp-")]
    public bool? OpenMPSupport = null;

    /// <summary>
    /// Determines the C++ language standard the compiler will enforce.
    /// </summary>
    public LanguageStandard LanguageStandard = LanguageStandard.Default;

    /// <summary>
    /// Determines the C language standard the compiler will enforce. It is recommended to use the latest version when possible.
    /// </summary>
    public LanguageStandard_C LanguageStandard_C = LanguageStandard_C.Default;

    /// <summary>
    /// Enables or suppresses conformance mode.
    /// </summary>
    public ConformanceMode ConformanceMode = ConformanceMode.Default;

    #endregion Language


    #region Precompiled Headers

    /// <summary>
    /// Create/Use Precompiled Header : Enables creation or use of a precompiled header during the build.
    /// </summary>
    public PrecompiledHeader PrecompiledHeader = PrecompiledHeader.NotUsing;

    #endregion Precompiled Headers


    #region External Includes

    /// <summary>
    /// Specifies whether to treat files included with angle brackets as external.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /external:anglebrackets
    /// </remarks>
    [CompilerFlag.Bool("/external:anglebrackets")]
    public bool TreatAngleIncludeAsExternal = false;

    /// <summary>
    /// Select how strict you want the compiler to be about code errors in external headers.
    /// </summary>
    public ExternalWarningLevel ExternalWarningLevel = ExternalWarningLevel.InheritWarningLevel;

    /// <summary>
    /// Specifies whether to evaluate warning level across template instantiation chain.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /external:templates-
    /// </remarks>
    [CompilerFlag.Bool("/external:templates-")]
    public bool? ExternalTemplatesDiagnostics = null;

    /// <summary>
    /// Disables code analysis for external headers.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /analyze:external-
    /// </remarks>
    [CompilerFlag.Bool("/analyze:external-")]
    public bool DisableAnalyzeExternal = false;

    #endregion External Includes


    #region Advanced

    /// <summary>
    /// Select the default calling convention for your application (can be overridden by function).
    /// </summary>
    public CallingConvention CallingConvention = CallingConvention.Cdecl;

    /// <summary>
    /// Generates a list of include files with compiler output.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /showIncludes
    /// </remarks>
    [CompilerFlag.Bool("/showIncludes")]
    public bool ShowIncludes = false;

    /// <summary>
    /// Use full paths in diagnostic messages.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /FC
    /// </remarks>
    [CompilerFlag.Bool("/FC")]
    public bool UseFullPaths = true;

    /// <summary>
    /// Omits the default C runtime library name from the .obj file.
    /// By default, the compiler puts the name of the library into the .obj file to direct the linker to the correct library.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /Zl
    /// </remarks>
    [CompilerFlag.Bool("/Zl")]
    public bool OmitDefaultLibName = false;

    #endregion Advanced
}
