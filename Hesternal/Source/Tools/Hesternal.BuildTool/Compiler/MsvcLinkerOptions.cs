using static Hesternal.BuildTool.Old.Msvc;

namespace Hesternal.BuildTool.Old;


public sealed class MsvcLinkerOptions : ILinkerOptions
{
    #region General

    /// <summary>
    /// Prints Linker Progress Messages
    /// </summary>
    public ShowProgress ShowProgress = ShowProgress.NotSet;

    /// <summary>
    /// Enables incremental linking.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /INCREMENTAL, <see langword="false"/> /INCREMENTAL:NO
    /// </remarks>
    [CompilerFlag.Bool("/INCREMENTAL", "/INCREMENTAL:NO")]
    public bool LinkIncremental = false;

    /// <summary>
    /// The /NOLOGO option prevents display of the copyright message and version number.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /NOLOGO
    /// </remarks>
    [CompilerFlag.Bool("/NOLOGO")]
    public bool SuppressStartupBanner = true;

    /// <summary>
    /// Specifies that the import library generated by this configuration should not be imported into dependent projects.
    /// </summary>
    public bool IgnoreImportLibrary = false;

    /// <summary>
    /// Specifies whether to register the primary output of this build.
    /// </summary>
    public bool RegisterOutput = false;

    /// <summary>
    /// When Register Output is enabled, Per-user redirection forces registry writes to HKEY_CLASSES_ROOT to be redirected to HKEY_CURRENT_USER.
    /// </summary>
    public bool PerUserRedirection = false;

    /// <summary>
    /// Specifies whether or not library outputs from project dependencies are automatically linked in.
    /// </summary>
    public bool LinkLibraryDependencies = true;

    /// <summary>
    /// Specifies whether or not the inputs to the librarian tool are used rather than the library file itself when linking in library outputs of project dependencies.
    /// </summary>
    public bool UseLibraryDependencyInputs = false;

    /// <summary>
    /// Specifies whether the linker should display a progress indicator showing what percentage of the link is complete.
    /// The default is to not display this status information.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /LTCG:STATUS, <see langword="false"/> /LTCG:NOSTATUS
    /// </remarks>
    [CompilerFlag.Bool("/LTCG:STATUS", "/LTCG:NOSTATUS")]
    public bool? LinkStatus = null;

    /// <summary>
    /// /ALLOWBIND:NO sets a bit in a DLL's header that indicates to Bind.exe that the image is not allowed to be bound.
    /// You may not want a DLL to be bound if it has been digitally signed (binding invalidates the signature).
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /ALLOWBIND, <see langword="false"/> /ALLOWBIND:NO
    /// </remarks>
    [CompilerFlag.Bool("/ALLOWBIND", "/ALLOWBIND:NO")]
    public bool? PreventDllBinding = null;

    /// <summary>
    /// /WX causes no output file to be generated if the linker generates a warning.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /WX, <see langword="false"/> /WX:NO
    /// </remarks>
    [CompilerFlag.Bool("/WX", "/WX:NO")]
    public bool? TreatLinkerWarningAsErrors = null;

    /// <summary>
    /// The /FORCE option tells the linker to create an .exe file or DLL even if a symbol is referenced but not defined or is multiply defined.
    /// It may create invalid exe file.
    /// </summary>
    public ForceFileOutput? ForceFileOutput = null;

    /// <summary>
    /// Prepares an image for hotpatching.
    /// </summary>
    public CreateHotPatchableImage? CreateHotPatchableImage = null;

    #endregion General


    #region Input

    /// <summary>
    /// The /NODEFAULTLIB option tells the linker to remove one or more default libraries from the list of libraries it searches when resolving external references.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /NODEFAULTLIB
    /// </remarks>
    [CompilerFlag.Bool("/NODEFAULTLIB")]
    public bool IgnoreAllDefaultLibraries = false;

    #endregion Input


    #region Debugging

    /// <summary>
    /// This option enables creation of debugging information for the .exe file or the DLL.
    /// </summary>
    public GenerateDebugInformation GenerateDebugInformation = GenerateDebugInformation.False;

    /// <summary>
    /// The /MAP option tells the linker to create a mapfile.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /MAP
    /// </remarks>
    [CompilerFlag.Bool("/MAP")]
    public bool GenerateMapFile = false;

    /// <summary>
    /// The /MAPINFO option tells the linker to include the specified information in a mapfile, which is created if you specify the /MAP option.
    /// EXPORTS tells the linker to include exported functions.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /MAPINFO:EXPORTS
    /// </remarks>
    [CompilerFlag.Bool("/MAPINFO:EXPORTS")]
    public bool MapExports = false;

    /// <summary>
    /// /ASSEMBLYDEBUG emits the DebuggableAttribute attribute with debug information tracking and disables JIT optimizations.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /ASSEMBLYDEBUG, <see langword="false"/> /ASSEMBLYDEBUG:DISABLE
    /// </remarks>
    [CompilerFlag.Bool("/ASSEMBLYDEBUG", "/ASSEMBLYDEBUG:DISABLE")]
    public bool? AssemblyDebug = null;

    #endregion Debugging


    #region System

    /// <summary>
    /// The /SUBSYSTEM option tells the operating system how to run the .exe file.
    /// The choice of subsystem affects the entry point symbol (or entry point function) that the linker will choose.
    /// </summary>
    public SubSystem SubSystem = SubSystem.Console;

    /// <summary>
    /// The /LARGEADDRESSAWARE option tells the linker that the application can handle addresses larger than 2 gigabytes.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /LARGEADDRESSAWARE, <see langword="false"/> /LARGEADDRESSAWARE:NO
    /// </remarks>
    [CompilerFlag.Bool("/LARGEADDRESSAWARE", "/LARGEADDRESSAWARE:NO")]
    public bool? LargeAddressAware = null;

    /// <summary>
    /// The /TSAWARE option sets a flag in the IMAGE_OPTIONAL_HEADER DllCharacteristics field in the program image's optional header.
    /// When this flag is set, Terminal Server will not make certain changes to the application.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /TSAWARE, <see langword="false"/> /TSAWARE:NO
    /// </remarks>
    [CompilerFlag.Bool("/TSAWARE", "/TSAWARE:NO")]
    public bool? TerminalServerAware = null;

    #endregion System


    #region Optimization

    /// <summary>
    /// /OPT:REF eliminates functions and/or data that are never referenced while /OPT:NOREF keeps functions and/or data that are never referenced.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /OPT:REF, <see langword="false"/> /OPT:NOREF
    /// </remarks>
    [CompilerFlag.Bool("/OPT:REF", "/OPT:NOREF")]
    public bool OptimizeReferences = false;

    // NOTE(v.matushkin): While it says that I can use =iterations,
    //  EnableCOMDATFolding variable type is bool in Microsoft.Build.CPPTasks.Common?
    /// <summary>
    /// Use /OPT:ICF[=iterations] to perform identical COMDAT folding.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /OPT:ICF, <see langword="false"/> /OPT:NOICF
    /// </remarks>
    [CompilerFlag.Bool("/OPT:ICF", "/OPT:NOICF")]
    public bool EnableCOMDATFolding = false;

    /// <summary>
    /// Specifies link-time code generation.
    /// </summary>
    public LinkTimeCodeGeneration? LinkTimeCodeGeneration = null;

    #endregion Optimization


    #region Windows Metadata

    /// <summary>
    /// Enables generation of a Windows Runtime Metadata (.winmd) file.
    /// </summary>
    public GenerateWindowsMetadata? GenerateWindowsMetadata = null;

    /// <summary>
    /// Specifies the file name for the Windows Runtime Metadata (.winmd) output file that is generated by the /WINMD linker option.
    /// </summary>
    /// <remarks>
    /// /WINMDFILE:filename
    /// </remarks>
    [CompilerFlag.String("/WINMDFILE:")]
    public string? WindowsMetadataFile = null;

    /// <summary>
    /// Specifies a key or a key pair to sign a Windows Runtime Metadata (.winmd) file.
    /// </summary>
    /// <remarks>
    /// /WINMDKEYFILE:filename
    /// </remarks>
    [CompilerFlag.String("/WINMDKEYFILE:")]
    public string? WindowsMetadataLinkKeyFile = null;

    /// <summary>
    /// Specifies a key container to sign a Windows Metadata (.winmd) file.
    /// </summary>
    /// <remarks>
    /// /WINMDKEYCONTAINER:name
    /// </remarks>
    [CompilerFlag.String("/WINMDKEYCONTAINER:")]
    public string? WindowsMetadataKeyContainer = null;

    /// <summary>
    /// Enables partial signing of a Windows Runtime Metadata (.winmd) file by putting the public key in the file.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /WINMDDELAYSIGN, <see langword="false"/> /WINMDDELAYSIGN:NO
    /// </remarks>
    [CompilerFlag.Bool("/WINMDDELAYSIGN", "/WINMDDELAYSIGN:NO")]
    public bool? WindowsMetadataLinkDelaySign = null;

    #endregion Windows Metadata


    #region Advanced

    /// <summary>
    /// The /ENTRY option specifies an entry point function as the starting address for an .exe file or DLL.
    /// </summary>
    /// <remarks>
    /// /ENTRY:function
    /// </remarks>
    [CompilerFlag.String("/ENTRY:")]
    public string? EntryPointSymbol = null;

    /// <summary>
    /// The /NOENTRY option is required for creating a resource-only DLL.
    /// Use this option to prevent LINK from linking a reference to _main into the DLL.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /NOENTRY
    /// </remarks>
    [CompilerFlag.Bool("/NOENTRY")]
    public bool NoEntryPoint = false;

    /// <summary>
    /// The /RELEASE option sets the Checksum in the header of an .exe file.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /RELEASE
    /// </remarks>
    [CompilerFlag.Bool("/RELEASE")]
    public bool SetChecksum = false;

    /// <summary>
    /// Specifies whether to generate an executable image that can be randomly rebased at load time by using the address space layout randomization (ASLR) feature of Windows.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /DYNAMICBASE, <see langword="false"/> /DYNAMICBASE:NO
    /// </remarks>
    [CompilerFlag.Bool("/DYNAMICBASE", "/DYNAMICBASE:NO")]
    public bool RandomizedBaseAddress = true;

    /// <summary>
    /// Marks an executable as having been tested to be compatible with Windows Data Execution Prevention feature.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /NXCOMPAT, <see langword="false"/> /NXCOMPAT:NO
    /// </remarks>
    [CompilerFlag.Bool("/NXCOMPAT", "/NXCOMPAT:NO")]
    public bool DataExecutionPrevention = true;

    // NOTE(v.matushkin): Seems like SupportUnloadOfDelayLoadedDLL and SupportUnloadOfDelayLoadedDLL should be combined into one option?
    //  If I get it right, it's two options in the IDE, but it's only one flag, the one specified later will override the previous one.

    /// <summary>
    /// The UNLOAD qualifier tells the delay-load helper function to support explicit unloading of the DLL.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /DELAY:UNLOAD
    /// </remarks>
    [CompilerFlag.Bool("/DELAY:UNLOAD")]
    public bool? SupportUnloadOfDelayLoadedDLL = null;

    /// <summary>
    /// The NOBIND qualifier tells the linker not to include a bindable IAT in the final image. The default is to create the bindable IAT for delay-loaded DLLs.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /DELAY:NOBIND
    /// </remarks>
    [CompilerFlag.Bool("/DELAY:NOBIND")]
    public bool? SupportNobindOfDelayLoadedDLL = null;

    /// <summary>
    /// The /MACHINE option specifies the target platform for the program.
    /// </summary>
    public TargetMachine TargetMachine = TargetMachine.MachineX64;

    /// <summary>
    /// Produces an output file that can be used with the Performance Tools profiler. Requires GenerateDebugInformation (/DEBUG) to be set.
    /// </summary>
    /// <remarks>
    /// <see langword="true"/> /PROFILE
    /// </remarks>
    [CompilerFlag.Bool("/PROFILE")]
    public bool Profile = false;

    #endregion Advanced
}
